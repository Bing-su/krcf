from collections.abc import Sequence
from typing import TypedDict

from .options import RandomCutForestOptions

__version__: str

class DiVector(TypedDict):
    high: list[float]
    low: list[float]

class RangeVector(TypedDict):
    values: list[float]
    upper: list[float]
    lower: list[float]

class InterpolationMeasure(TypedDict):
    measure: DiVector
    distance: DiVector
    probability_mass: DiVector
    sample_size: float

class RandomCutForest:
    def __init__(self, options: RandomCutForestOptions): ...
    def shingled_point(self, point: Sequence[float]) -> list[float]: ...
    def update(self, point: Sequence[float]) -> None: ...
    def score(self, point: Sequence[float]) -> float: ...
    def displacement_score(self, point: Sequence[float]) -> float: ...
    def attribution(self, point: Sequence[float]) -> DiVector: ...
    def near_neighbor_list(
        self, point: Sequence[float], percentile: int
    ) -> list[tuple[float, Sequence[float], float]]: ...
    def density(self, point: Sequence[float]) -> float: ...
    def directional_density(self, point: Sequence[float]) -> DiVector: ...
    def density_interpolant(self, point: Sequence[float]) -> InterpolationMeasure: ...
    def extrapolate(self, look_ahead: int) -> RangeVector: ...
    def dimensions(self) -> int: ...
    def shingle_size(self) -> int: ...
    def is_internal_shingling_enabled(self) -> bool: ...
    def is_output_ready(self) -> bool: ...
    def entries_seen(self) -> int: ...
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, value: str) -> RandomCutForest: ...
    def to_msgpack(self) -> bytes: ...
    @classmethod
    def from_msgpack(cls, value: bytes) -> RandomCutForest: ...
